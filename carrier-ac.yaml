esp8266:
  board: esp01_1m

esphome:
  name: carrier-ac
  friendly_name: carrier_ac

packages:
  basic: !include
    file: includes/basic.yaml
    vars:
      # secrets don't support substitution
      # CHANGE THIS TO THE NAME OF THE DEVICE!!!
      <<: !secret carrier_ac_params
      ap_ssid: Carrier-Ac
  em_base: !include includes/logic/energy_management/base.yaml

# Disable logging over UART (required)
logger:
  baud_rate: 0

# UART settings for Midea dongle (required)
uart:
  tx_pin: 1         # hardware dependant
  rx_pin: 3         # hardware dependant
  baud_rate: 9600

# Main settings
climate:
- platform: midea
  id: carrier_ac
  name: Midea Climate         # Use a unique name.
  autoconf: true              # Autoconfigure most options.
  beeper: true                # Beep on commands.
  supported_modes:            # Optional. All capabilities in this section may be detected by autoconf.
  - FAN_ONLY
  - HEAT_COOL
  - COOL
  - HEAT
  - DRY
  custom_fan_modes:           # Optional
  - SILENT
  - TURBO
  supported_presets:          # Optional. All capabilities in this section may be detected by autoconf.
  - ECO
  - BOOST
  - SLEEP
  supported_swing_modes:      # Optional
  - VERTICAL
  outdoor_temperature:        # Optional. Outdoor temperature sensor (may display incorrect values after long inactivity).
    name: Temp
  humidity_setpoint:          # Optional. Indoor humidity sensor (only for devices that support this feature).
    name: Humidity
  on_state:
    lambda: |-
      id(ac_update_action)(x.mode != CLIMATE_MODE_OFF);

switch:
- platform: template
  id: device_on_optimistic
  name: Device on (optimistic)
  optimistic: False
  entity_category: diagnostic
  turn_on_action:
    lambda: |-
      id(switch_update_action)(true, *id(device_on_optimistic));
  turn_off_action:
    lambda: |-
      id(switch_update_action)(false, *id(device_on_optimistic));

binary_sensor:
- name: Waiting for action
  platform: template
  lambda: return id(waiting_for_action);
  entity_category: diagnostic
- name: Second toggle
  platform: template
  lambda: return id(second_toggle);
  entity_category: diagnostic
- name: External update
  platform: template
  lambda: return id(external_update);
  entity_category: diagnostic
- name: Action sent
  platform: template
  lambda: return id(action_sent);
  entity_category: diagnostic

sensor:
- platform: template
  name: Total updates
  entity_category: diagnostic
  lambda: return id(updates);


energy_management:
  id: $id_em
  set_device_state:
    lambda: |-
      bool prev = id(device_on_optimistic).state;
      id(update_from_em) = true;
      switch_to ? id(device_on_optimistic).turn_on() : id(device_on_optimistic).turn_off();
      return prev;

script:
- id: delayed_action
  mode: restart
  then:
  - lambda: |-
      ESP_LOGD("", "Waiting before sending action");
      id(action_sent) = false;
  - delay: 1s
  - while:
      condition:
        lambda: return id(waiting_for_action);
      then:
      - lambda: |-
          //ESP_LOGD("", "Sending action");
          id(action_sent) = true;
          if (id(device_on_optimistic).state != id(second_toggle)) {
            id(carrier_ac).do_power_on();
          } else {
            id(carrier_ac).do_power_off();
          }
      - delay: 4s

globals:
- id: ac_update_action
  type: std::function<void(bool)>
  initial_value: |-
    [](bool turn_on) {
      //if ((turn_on == id(last_ac_state)) && !waiting_for_action) {
      //  ESP_LOGD("", "Ignoring update from AC since it's not due to power status");
      //  return;
      //}
      id(last_ac_state) = turn_on;
      if (id(waiting_for_action)) {
        bool expected_action = id(device_on_optimistic).state != id(second_toggle);
        bool is_wrong_action = expected_action != turn_on;
        if (!id(second_toggle) || is_wrong_action) {
          id(stop_delayed_action)();
        } else {
          id(second_toggle) = false;
          id(delayed_action).execute();
        }
        if (!is_wrong_action)
          return;
      }
      if (id(device_on_optimistic).state == turn_on) return;
      id(external_update) = true;
      if (turn_on) {
        id(device_on_optimistic).turn_on();
      } else {
        id(device_on_optimistic).turn_off();
      }
    }
- id: stop_delayed_action
  type: std::function<void()>
  initial_value: |-
    []() {
      id(waiting_for_action) = false;
      id(second_toggle) = false;
      id(delayed_action).stop();
      id(action_sent) = false;
    }
- id: switch_update_action
  type: std::function<bool(bool, switch_::Switch &)>
  # return wether or not the update was triggered by the AC changing state
  # maybe turn all this into a "single depth queue output switch"?
  initial_value: |-
    [](bool turn_on, auto &self) {
      //ESP_LOGD("", "Starting switch update");
      id(updates)++;
      
      bool allow = id(on_pre_switch_update)(turn_on);
      if (allow) {
        //ESP_LOGD("", "Publishing state update since state change is allowed");
        self.publish_state(turn_on);
      }

      auto start_delayed_action = []() {
        id(waiting_for_action) = true;
        id(second_toggle) = false;
        id(delayed_action).execute();
      };

      if (id(external_update)) {
        id(external_update) = false;
        //ESP_LOGD("", "Update was external");
        if (!allow) {
          //ESP_LOGD("", "Reverting unallowed external action");
          start_delayed_action();
        }
        return true;
      }

      if (!allow) {
        //ESP_LOGD("", "Update to %s not allowed", turn_on ? "on" :"off");
        return false;
      }
      
      if (id(waiting_for_action)) {
        // if we haven't sent anything yet and we get another toggle
        // then we're back at the beginning
        //ESP_LOGD("", "Action sent :%s", action_sent ? "yes" :"no");
        if (!id(action_sent)) {
          //ESP_LOGD("", "Action not yet sent, cancelling");
          id(stop_delayed_action)();
          return false;
        }

        // a third toggle cancels the second one, since we're going
        // off -> on -> off -> on
        // is the same as
        // off -> on
        // as long as we're still trying to send the first `on`
        id(second_toggle) = !id(second_toggle);

        //ESP_LOGD("", "Restarting action to reset timer");
        id(delayed_action).execute();
        return false;
      }
      
      //ESP_LOGD("", "Starting action");
      start_delayed_action();
      return false;
    }
- id: on_pre_switch_update
  type: std::function<bool(bool)>
  # returns true if the update is allowed
  initial_value: |-
    [](bool turn_on) {
      if (id(update_from_em)) {
        id(update_from_em) = false;
        return true;
      }
      return turn_on == id($id_em).set_device_state(turn_on);
    }
- id: waiting_for_action
  type: bool
  restore_value: no
  initial_value: "false"
- id: second_toggle
  type: bool
  initial_value: "false"
- id: external_update
  type: bool
  initial_value: "false"
- id: action_sent
  type: bool
  initial_value: "false"
- id: update_from_em
  type: bool
  initial_value: "false"
- id: last_ac_state
  type: bool
  initial_value: "false"
- id: updates
  type: int
  initial_value: "0"

button:
- platform: template
  name: Turn on
  on_press:
    lambda: id(carrier_ac).do_power_on();
- platform: template
  name: Turn off
  on_press:
    lambda: id(carrier_ac).do_power_off();