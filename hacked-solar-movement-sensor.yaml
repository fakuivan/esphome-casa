packages:
  basic: !include
    file: includes/basic.yaml
    vars:
      # secrets don't support substitution
      # CHANGE THIS TO THE NAME OF THE DEVICE!!!
      <<: !secret hacked_solar_movement_sensor_params
      ap_ssid: Hacked-Solar-Movement-Sensor
  pir: !include
    file: includes/devices/hacked_solar_movement_sensor/pir.yaml
  light: !include
    file: includes/devices/hacked_solar_movement_sensor/light.yaml

esp8266:
  board: esp01_1m

esphome:
  name: hacked-solar-movement-sensor
  friendly_name: hacked_solar_movement_sensor
  on_boot:
  # setup_priority::HARDWARE - 1
  - priority: 799
    then:
    - lambda: |-
        if (id(main_button).state) {
          id(button_wakeup) = true;
        }
        id(deep_sleep_reset) = ESP.getResetInfoPtr()->reason == REASON_DEEP_SLEEP_AWAKE;

        if (id(pir_left_on).has_value() && id(deep_sleep_reset)) {
          id(pir_state) = id(pir_left_on).value() ? pir_states::ON : pir_states::OFF;
        }
        id(pir_left_on) = {};
  # setup_priority::LATE
  - priority: -100
    then:
    - lambda: |-
        float batt_voltage = id(get_battery_voltage)();
        if (batt_voltage <= $low_battery_cutoff + $low_battery_hysteresis) {
          id(on_battery_too_low)->execute();
          return;
        }
        id(battery_voltage).publish_state(batt_voltage);
        id(pir_turn_on_off)->execute(true);
        id(wifi_0).enable();
        id(initialized) = true;
        id(start_deep_sleep_hard_countdown)->execute(30);

switch:
- platform: gpio
  internal: True
  id: allow_reset
  pin:
    number: GPIO01
    mode: output
    inverted: False
  restore_mode: ALWAYS_OFF
- platform: template
  id: prevent_sleep
  entity_category: diagnostic
  name: Prevent sleep
  optimistic: True
  restore_mode: ALWAYS_OFF

# TODO: implement the sleep awake cycle:
# - Turn on via event
# - Wait for an API connection to be stablished with set timeout
#   - If timeout expires, set a flag indicating there was a
#     missing event and go into deep sleep
# - Wait for event to conclude
# - Enter deep sleep
# Note: maybe add an exponential backoff with saturation to prevent
# us from turning on and off for repeated events.

# To keep track of time between sleeps the rtc can be used: https://github.com/nodemcu/nodemcu-firmware/tree/release/app/include/rtc

script:
- id: reset_deep_sleep_soft_countdown
  mode: restart
  parameters:
    awake_seconds: uint
  then:
  - delay: !lambda 'return awake_seconds*1000;'
  - while:
      condition:
        lambda: 'return !id(sleep_seconds).has_value() || !id(can_sleep)();'
      then:
      - delay: !lambda 'return awake_seconds*1000;'
  - script.execute:
      id: deep_sleep_enter
      sleep_seconds: !lambda 'return id(sleep_seconds).value();'
      turn_pir_off: "false"
- id: start_deep_sleep_hard_countdown
  mode: single
  parameters:
    awake_seconds: uint
  then:
  - delay: !lambda 'return awake_seconds*1000;'
  - while:
      condition:
        lambda: 'return !id(sleep_seconds).has_value() || !id(can_sleep)();'
      then:
      - delay: !lambda 'return awake_seconds*1000;'
  - script.execute:
      id: deep_sleep_enter
      sleep_seconds: !lambda 'return id(sleep_seconds).value();'
      turn_pir_off: "false"
- id: deep_sleep_enter
  mode: single
  parameters:
    sleep_seconds: optional<float>
    turn_pir_off: bool
  then:
  - switch.turn_on: allow_reset
  - if:
      condition:
        lambda: 'return turn_pir_off;'
      then:
      - script.execute:
          id: pir_turn_on_off
          turn_on: "false"
      - script.wait: pir_turn_on_off
  - lambda: |-
      if (id(pir_state) == pir_states::OFF) {
        id(pir_left_on) = false;
      } else if (id(pir_state) == pir_states::ON) {
        id(pir_left_on) = true;
      }
      id(pir_left_on) = {};
  - if:
      condition:
        lambda: 'return sleep_seconds.has_value();'
      then:
      - deep_sleep.enter:
          sleep_duration: !lambda 'return (*sleep_seconds)*1000;'
      else:
      - deep_sleep.enter:
- id: on_battery_too_low
  mode: single
  then:
  - script.execute:
      id: deep_sleep_enter
      sleep_seconds: !lambda 'return optional<float>();'
      turn_pir_off: "true"
- id: api_client_update
  parameters:
    client_info: std::string
    connected: bool
  mode: queued
  then:
  - lambda: |-
      if (client_info.find("Home Assistant ") == 0) {
        // give 5 seconds to HA to pull values and reconnect if disconnected
        id(reset_deep_sleep_soft_countdown)->execute(5);
      }

substitutions:
  adc_offset: "2.313f"
  adc_scale: "0.005528f"
  adc_samples: "100"
  # Wait for the battery to be above 3.0 + 0.1 to boot
  low_battery_hysteresis: "0.1f"
  low_battery_cutoff: "3.0f"

globals:
- id: wake_from_deep_sleep
  type: bool
  initial_value: "false"
- id: pir_left_on
  type: optional<bool>
  initial_value: "optional<bool>()"
  restore_value: True
- id: button_wakeup
  type: bool
  initial_value: "false"
- id: initialized
  type: bool
  initial_value: "false"
- id: deep_sleep_reset
  type: bool
  initial_value: "false"
- id: get_battery_voltage
  type: std::function<float()>
  initial_value: |-
    [](){
      // Should not overflow as long as we keep it within
      // `adc_samples < pow(2, sizeof(uint)-adc_bits)`
      uint value = 0;
      for (uint16_t i = $adc_samples; i > 0; i--) {
        value += analogRead(0);
      }
      return ((float)value + ($adc_samples*$adc_offset)) * ($adc_scale/$adc_samples);
    }
  # Wait for both pir and buttons to be off before going to sleep
- id: can_sleep
  type: std::function<bool()>
  initial_value: |-
    [](){
      return !(id(pir_output).state || id(main_button).state || id(prevent_sleep).state);
    }
- id: sleep_seconds
  type: optional<uint>
  initial_value: 3*60*60

api:
  on_client_connected:
  - script.execute:
      id: api_client_update
      client_info: !lambda return client_info;
      connected: "false"
  on_client_disconnected:
  - script.execute:
      id: api_client_update
      client_info: !lambda return client_info;
      connected: "true"

sensor:
- platform: template
  id: battery_voltage
  name: Battery voltage
  device_class: voltage
  entity_category: diagnostic
  unit_of_measurement: V

  accuracy_decimals: 2
  lambda: return id(get_battery_voltage)();
  update_interval: 5s

  on_value_range:
    below: !lambda 'return $low_battery_cutoff;'
    then:
    - if:
        condition:
          lambda: 'return id(initialized);'
        then:
        - script.execute:
            id: on_battery_too_low

- platform: template
  name: Sleep time
  entity_category: diagnostic
  unit_of_measurement: s
  lambda: 'return id(sleep_seconds).value_or(-1.);'

binary_sensor:
- platform: gpio
  id: main_button
  name: Button
  pin:
    number: GPIO02
    mode: input
    inverted: True
- platform: template
  name: Button wakeup
  entity_category: diagnostic
  lambda: 'return id(button_wakeup);'
- platform: template
  name: PIR wakeup
  entity_category: diagnostic
  lambda: 'return id(pir_motion_wakeup);'
- platform: template
  name: Reset from sleep
  entity_category: diagnostic
  lambda: 'return id(deep_sleep_reset);'
- platform: template
  name: Can sleep
  entity_category: diagnostic
  lambda: 'return id(can_sleep)();'

text_sensor:
- platform: template
  name: PIR state
  entity_category: diagnostic
  lambda: 'return std::string(pir_states_to_str(id(pir_state)));'

# disable logging via uart
logger:
  baud_rate: 0

deep_sleep:

wifi:
  enable_on_boot: False
  id: wifi_0